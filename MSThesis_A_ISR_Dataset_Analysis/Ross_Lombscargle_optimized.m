function Ross_Lombscargle(inputdata,dupe_elim) %Note: optimized hopefully works still
% LOMBSCARGLE(INPUTDATA, DUPE_ELIM) performs a Lomb-Scargle periodogram (spectral) analysis on an n x 2 matrix of data 
% (inputdata = x(i),y(i)) that are not necessarily evenly spaced. (For evenly spaced data, more traditional
% Fourier-based spectral methods may be more appropriate.)
% 
% DUPE_ELIM (= 0 or 1) is an optional argument that 
% will prompt the program (if dupe_elim == 1) to eliminate duplicated samples from the analysis.
% The default value is 0.
%
% This program will plot and spectrally analyze the input data, and then plot the power spectrum of the data.
% The program is also capable of overlaying a signal of known frequency and amplitude; this may be helpful for
% spectral calibration. The resulting spectrum plot will also include significance levels. Finally, the program
% will reconstruct a plot of frequencies determined to be "significant" (at alpha = 0.05); for this reconstruction,
% frequencies within 5% of the calibration signal (if used) will be discarded. Significant frequencies and powers
% are written to the MATLAB command window.
%
% (This program is based on a Lomb-Scargle implementation in Press, Teukolsky, et al. Numerical Recipes,
% "Spectral Analysis of Unevenly Sampled Data." Use of this program requires an understanding of the
% Press/Teukolsky implementation, inculding the usage of hifac and ofac variables. The user is referred 
% to that source for a thorough discussion of the algorithms. In addition, the references cited in 
% Press/Teukolsky are quite helpful--particularly Scargle 1982, and Horne and Baliunas, 1986.)
%
% Note that there is an over-reliance in this code on global variables, and that no attempts have been made
% to vectorize for loops or to optimize the implementation. Perhaps in the next version....
%
% An optional file (INPUTTOLOMB.M) is also available for download, and includes code for easily generating 
% test data with known frequencies and amplitudes. This file is helpful for users trying to understand the output
% generated by lombscargle.
%
% Written by Brett Shoelson, Ph.D.
% 3/1/1999. Last modification: 10/25/01.
% Modified by Sumanta Sarkhel, Ph.D. on 01 Aug, 2011.
% Rewritten to be efficient by Ross Dinsmore, no useful titles, on sometime
% in 2016

%% Setup

if nargin == 0
	error('Requires at least one input argument comprising n x 2 data matrix to analyze.');
elseif nargin == 1
	dupe_elim = 0;
end

if size(inputdata,2) ~= 2
	error('Input data must be an n x 2 matrix of numbers.')
end

numin=size(inputdata,1); %get size in

%Eliminate duplicates
if dupe_elim
	inputdata=unique(inputdata,'rows');
	numdat=size(inputdata,1);
	if numin~=numdat
% 		beep;
		fprintf('\n\n***** %i Duplicate data points omitted.\n',size(inputdata,1)-size(inputdata,1));
	end
else
% 	inputdata = inputdata;
end

x=inputdata(:,1); %fully import data
x = reshape(x,1,length(x)); %force a row vector as that's what's assumed
y=inputdata(:,2); %fully import data
y = reshape(y,1,length(y)); %force a row vector as that's what's assumed

tmin=min(x);
tmax=max(x);
n=length(x);


%% Freq Analysis

%np = number of frequencies examined (= length of output freqs file)
%ofac = oversampling parameter (typically >= 4 for best results)
%hifac = input parameter defined as fhi/fc, where:
%fhi is the highest frequency examined, and
%fc is the Nyquist frequency (=N/(2T)).

% nuhifac=questdlg('Enter fhi or hifac?','Cutoff Frequency','fhi','hifac','fhi');
% if strcmp(nuhifac,'fhi')
% 	fhi = getfhi;
% 	hifac=fhi*2*(tmax-tmin)/n;
% elseif strcmp(nuhifac,'hifac')
% 	hifac = 1;
% 	fhi=hifac*n/(2*(tmax-tmin));
% 	fprintf('\nfhi = %f (in Hertz)',fhi);
% 	info{lines}=sprintf('fhi = %f (in Hertz)',fhi);
% 	lines=lines+1;
% end

hifac = 1;
fhi=hifac*n/(2*(tmax-tmin));

ofac = 4;

% np=ofac*hifac*n*0.5;
nout=floor(0.5*ofac*hifac*n);
ave=mean(y);
variance=var(y);
xmin=tmin;
xmax=tmax;
xdif=xmax-xmin;
xave=0.5*(xmax+xmin);
pnow=1/(xdif*ofac);

% wpr = zeros(1,n);
% wpi = zeros(1,n);
% wr = zeros(1,n);
% wi = zeros(1,n);
% for jval=1:n
% 	arg=2*pi*((x(jval)-xave)*pnow);
% 	wpr(jval)=-2*sin(0.5*arg)^2;
% 	wpi(jval)=sin(arg);
% 	wr(jval)=cos(arg);
% 	wi(jval)=wpi(jval);
% end
arg = 2.*pi.*((x-xave).*pnow);
wpr = -2.*sin(0.5*arg).^2;
wpi = sin(arg);
wr = cos(arg);
wi = wpi;

px = zeros(1,nout); %preallocate
py = zeros(1,nout); %preallocate
freqs = zeros(nout,2); %preallocate
for ival=1:nout
	px(ival)= pnow; %update as we go
	
%     sumsh=0; %hopefully efficiency upped below
% 	sumc=0;
%     for jval=1:n
% 		c=wr(jval);
% 		s=wi(jval);
% 		sumsh=sumsh+s*c;
% 		sumc=sumc+(c-s)*(c+s);
%     end
    sumsh = sum(wr.*wi); %replicate sum for loop
    sumc = sum( (wr-wi).*(wr+wi) ); %replicate sum for for loop again
    
    
	wtau=0.5*atan2(2*sumsh,sumc);
	swtau=sin(wtau);
	cwtau=cos(wtau);
% 	sums=0;
% 	sumc=0;
% 	sumsy=0;
% 	sumcy=0;
% 	for jval=1:n
% 		s=wi(jval);
% 		c=wr(jval);
% 		ss=s*cwtau-c*swtau;
% 		cc=c*cwtau+s*swtau;
% 		sums=sums+ss^2;
% 		sumc=sumc+cc^2;
% 		yy=y(jval)-ave;
% 		sumsy=sumsy+yy*ss;
% 		sumcy=sumcy+yy*cc;
% 		wtemp=wr(jval);
% 		wr(jval)=(wr(jval)*wpr(jval)-wi(jval)*wpi(jval))+wr(jval);
% 		wi(jval)=(wi(jval)*wpr(jval)+wtemp*wpi(jval))+wi(jval);
%     end
    ss = (wi.*cwtau - wr.*swtau); %reused so calc'd once
    cc = (wr.*cwtau - wi.*swtau); 
    sums = sum( ss.^2 ); %replicate for loop sum
    sumc = sum( cc.^2 ); %replicate for loop sum
    sumsy = sum( (y - ave).*ss ); %replcate for loop thing
    sumcy = sum( (y - ave).*cc ); %replcate for loop thing
    wrTemp = wr; %need to hold this for wi
    wr = wr.*wpr - wi.*wpi + wr; %edit this after that stuff, as per the for loop
    wi = wi.*wpr + wrTemp.*wpi + wi; %edit this after that stuff, as per the for loop
    
	py(ival)=0.5*(sumcy^2/sumc+sumsy^2/sums)/variance;
	
	%WRITE OUTPUT
	freqs(ival,1)=px(ival);
	freqs(ival,2)=py(ival);
	pnow=pnow+1/(ofac*xdif);
end

%effm is an estimate of the number of *independent* frequencies
effm=2*nout/ofac;

%The following computation of prob is valid for small values only:
%    prob=effm*expy.
%The following computation of prob is always valid, but presupposes no data clumping:
%    prob=1-(1-expy)^effm.
if ( ~isempty(effm) && effm~=0 )

else
	fprintf('period.m: No frequencies to analyze.');
end %if ~isempty(effm) & effm~=0


%% Save the Data

if ~isempty(freqs)
    %======================================================================
    % Sumanta Sarkhel's edited portion........
    
    fid=fopen('power_freq.txt','wt');    
        a_n=freqs;
        a_n1=a_n(:,1);
        a_n2=a_n(:,2);
        [row, ~]=size(a_n);
        K=row;
        gf=(1-(.05/K)^(1/(K-1))); %for gf and gs see pg 934-935 of the journal paper "SPECTRUM: SPECTRAL ANALYSIS OF UNEVENLY SPACED PALEOCLIMATIC TIME SERIES" by SCHULZ and STATTEGGER
        gs=0.4*gf; %Computers & Geosciences Vol. 23, No. 9, pp. 929-945, 1997 
        for h=1:row
            peri(h,:)=1/a_n1(h);
        end
        Pnorm=a_n2./sum(a_n2);
        sumo=[a_n1  Pnorm (a_n1*0+gf) (a_n1*0+gs) peri];
        fprintf (fid, 'This file gives the Normalized Power Vs Frequency.');
        fprintf (fid, ' It also provides the values of "gf" and "gs" calculated from Fisher and Siegel test respectively.\n');
        fprintf(fid, '\ngf = %f',gf);
        fprintf(fid, '\ngs = %f\n\n',gs);
        fprintf(fid, '\nfhi (Hz) = %f',fhi);
        fprintf(fid, '\nhifac = %f',hifac);
        fprintf(fid, '\nofac = %f\n\n\n',ofac);
        fprintf (fid, 'Frequency (Hz)   Normalized Power   gf       gs         Period\n\n\n');
        fprintf (fid, '%8.6f \t %8.6f \t %6.6f   %6.6f   %8.6f\n', sumo');
    fclose(fid);

    
    %======================================================================

end %if ~isempty(freqs)
			
end %if isempty(freqs)

